# Basically Vitalik Buterins namecoin, but with different indata.
#
# msg.data[0] is the filename
# msg.data[1] is the first 32 bytes of the hash
# msg.data[2] is the last 2 bytes of the hash

if !contract.storage[msg.data[0]]: # Is the key not yet taken?
    # Then take it!
    # We need store both parts of the hash at two consecutive storage addresses, starting with msg.data[0]
    contract.storage[msg.data[0]] = msg.data[1]
    contract.storage[msg.data[0] + 1] = msg.data[2]
    return(1)
else:
    return(0) // Otherwise do nothing