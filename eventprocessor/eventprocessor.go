// The event processor handles events that are generated by the
// different components/modules.
package eventprocessor

import (
	"encoding/json"
	"github.com/eris-ltd/decerver/interfaces/decerver"
	"github.com/eris-ltd/decerver/interfaces/events"
	"github.com/eris-ltd/decerver/interfaces/logging"
	"github.com/eris-ltd/decerver/interfaces/modules"
	"log"
	"sync"
)

var logger *log.Logger = logging.NewLogger("Event Processor")

// Typedef for map of subscriptions
type SubMap map[string]*subscriptions

// a collection of subscribers.
type subscriptions struct {
	srs []events.Subscriber
}

// Add a new subscriber.
func (ss *subscriptions) add(sub events.Subscriber) {
	ss.srs = append(ss.srs, sub)
}

// Remove a subscriber.
func (ss *subscriptions) remove(subId string) bool {
	theIdx := -1
	for i, sub := range ss.srs {
		if sub.Id() == subId {
			theIdx = i
			break
		}
	}
	if theIdx >= 0 {
		// DEBUG
		logger.Println("Subscriber removed: " + subId)
		ss.srs = append(ss.srs[:theIdx], ss.srs[theIdx+1:]...)
		return true
	}
	return false
}

// Create a new 'subscriptions' object. The subscriber slice starts
// out with size 0 and is appended to and deleted from by the add and
// remove methods.
func newSubscriptions() *subscriptions {
	ss := &subscriptions{}
	ss.srs = make([]events.Subscriber, 0)
	return ss
}

type trafficData struct {
	// The total amount of events that are posted.
	EventsPosted uint64 `json:"events_posted"`
	// The number of events received sorted by source (module)
	EventsPostedBySource map[string]uint64 `json:"events_posted_by_source"`
	// Number of events passed on to a subscriber (meaning the
	// source, type and target matches)
	EventsSubReceivedBySource map[string]uint64 `json:"events_received_by_subs"`
	// The number of events from each module that was relayed but
	// not processed because of 0 subs.
	EventsNoSourceSubsBySource map[string]uint64 `json:"events_no_source_subs"`
	// This happens when there are subs to the source, but not
	// to the event type that's posted.
	EventsNoEvtSubs map[string]map[string]uint64 `json:"events_no_event_type_subs"`
}

func newTrafficData() *trafficData {
	td := &trafficData{}
	td.EventsPostedBySource = make(map[string]uint64)
	td.EventsSubReceivedBySource = make(map[string]uint64)
	td.EventsNoSourceSubsBySource = make(map[string]uint64)
	td.EventsNoEvtSubs = make(map[string]map[string]uint64)
	return td
}

func (td *trafficData) incPosted(src string) {
	td.EventsPosted++
	if _, ok := td.EventsPostedBySource[src]; !ok {
		td.EventsPostedBySource[src] = uint64(1)
	} else {
		td.EventsPostedBySource[src] = td.EventsPostedBySource[src] + uint64(1)
	}
}

func (td *trafficData) incNoSubBySource(src string) {
	if _, ok := td.EventsNoSourceSubsBySource[src]; !ok {
		td.EventsNoSourceSubsBySource[src] = uint64(1)
	} else {
		td.EventsNoSourceSubsBySource[src] = td.EventsNoSourceSubsBySource[src] + uint64(1)
	}
}

func (td *trafficData) incNoEvtSub(src, evt string) {
	if _, ok := td.EventsNoEvtSubs[src]; !ok {
		newMap := make(map[string]uint64)
		newMap[evt] = uint64(1)
		td.EventsNoEvtSubs[src] = newMap
	} else {
		td.EventsNoEvtSubs[src][evt] = td.EventsNoEvtSubs[src][evt] + uint64(1)
	}
}

func (td *trafficData) incrementReceived(src string) {
	if _, ok := td.EventsSubReceivedBySource[src]; !ok {
		td.EventsSubReceivedBySource[src] = uint64(1)
	} else {
		td.EventsSubReceivedBySource[src] = td.EventsSubReceivedBySource[src] + uint64(1)
	}
}

// The event processor handles subscribers and events.
type EventProcessor struct {
	// Mutex for subscribe, unsubscribe and post.
	mutex *sync.Mutex
	// Store subscribers by source (which module they're subscribing to)
	subs map[string]SubMap
	// Store subs by id. This keeps a map of subID->sub for fast (constant speed) removal.
	byId map[string]events.Subscriber
	// A reference to the module registry. We need this in order to relay
	// subscription info to modules in case they want to filter their outgoing
	// events, or do other stuff.
	moduleManager modules.ModuleManager
	// Traffic data
	td *trafficData
	// Whether or not we're in debugging mode.
	debug bool
}

func NewEventProcessor(dc decerver.Decerver) events.EventProcessor {
	ep := &EventProcessor{}
	ep.mutex = &sync.Mutex{}
	ep.subs = make(map[string]SubMap)
	ep.byId = make(map[string]events.Subscriber)
	ep.moduleManager = dc.ModuleManager()
	return ep
}

// TODO Not sure what the error is supposed to do yet
func (ep *EventProcessor) Post(e events.Event) error {
	ep.mutex.Lock()
	defer ep.mutex.Unlock()
	src := e.Source
	ee := e.Event
	if ep.debug {
		ep.td.incPosted(src)
		logger.Println("Receiving event '" + ee + "' from '" + src + "'.")
	}

	sourceSubs := ep.subs[src]
	if sourceSubs == nil || len(sourceSubs) == 0 {
		if ep.debug {
			logger.Println("No subscribers to events published by: " + src + ". Skipping.")
			ep.td.incNoEvtSub(src,ee)
		}
		return nil
	}

	eeSubs := sourceSubs[ee]
	if eeSubs == nil || len(eeSubs.srs) == 0 {
		if ep.debug {
			logger.Println("No subscribers to events of type '" + ee + "' published by '" + src + "'. Skipping.")
			ep.td.incNoEvtSub(src, ee)
		}
		return nil
	}

	for _, sub := range eeSubs.srs {
		if sub.Target() == e.Target {
			if ep.debug {
				logger.Println("Found subscriber")
				logger.Printf("Chan: %v\n", sub)
				ep.td.incrementReceived(src)
			}
			sub.Post(e)
		}
	}
	return nil
}

func (ep *EventProcessor) Subscribe(sub events.Subscriber) error {
	ep.mutex.Lock()
	defer ep.mutex.Unlock()
	src := sub.Source()
	if ep.debug {
		logger.Println("New subscription registering: " + src)
	}
	srcSubs, okSrc := ep.subs[src]
	if !okSrc {
		srcSubs = make(SubMap)
		ep.subs[src] = srcSubs
	}

	evt := sub.Event()
	evts, okEvt := srcSubs[evt]

	if !okEvt {
		evts = newSubscriptions()
		srcSubs[evt] = evts
	}

	evts.add(sub)
	ep.byId[sub.Id()] = sub

	// Call subscribe on module to let it do filtering etc.
	ep.moduleManager.Modules()[src].Subscribe(sub.Id(), sub.Event(), sub.Target())
	logger.Printf("New subscriber added to: %s (%s)\n", sub.Source(), sub.Event())
	return nil
}

// TODO not sure what the error is supposed to do yet
func (ep *EventProcessor) Unsubscribe(id string) error {
	ep.mutex.Lock()
	defer ep.mutex.Unlock()
	sub, ok := ep.byId[id]
	if !ok {
		logger.Println("No subscriber with id: " + id)
		return nil
	}
	ep.moduleManager.Modules()[sub.Source()].UnSubscribe(sub.Id())
	ep.subs[sub.Source()][sub.Event()].remove(id)
	delete(ep.byId, id)
	return nil
}

func (ep *EventProcessor) TrafficData() string {
	if ep.debug {
		bts, _ := json.MarshalIndent(ep.td, "", "\t")
		str := string(bts)
		// TODO remove
		logger.Println(str)
		return str
	} else {
		logger.Println("Event Traffic Data not available (debug mode must be enabled).")
		return "N/A"
	}
}
